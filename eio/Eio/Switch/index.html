<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Switch (eio.Eio.Switch)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Switch</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Switch</span></code></h1><p>Grouping fibers and other resources so they can be turned off together.</p><p>Many resources in Eio (such as fibers and file handles) require a switch to be provided when they are created. The resource cannot outlive its switch.</p><p>If a function wants to create such resources, and was not passed a switch as an argument, it will need to create a switch using <a href="#val-run"><code>run</code></a>. This doesn't return until all resources attached to it have been freed, preventing the function from leaking resources.</p><p>Any function creating resources that outlive it needs to be given a switch by its caller.</p><p>Each switch includes its own <a href="../Cancel/index.html#type-t"><code>Cancel.t</code></a> context. Calling <a href="#val-fail"><code>fail</code></a> cancels all fibers attached to the switch and, once they have exited, reports the error.</p><p>Note: this concept is known as a &quot;nursery&quot; or &quot;bundle&quot; in some other systems.</p><p>Example:</p><pre class="language-ocaml"><code>Switch.run (fun sw -&gt;
   let flow = Dir.open_in ~sw dir &quot;myfile.txt&quot; in
   ...
);
(* [flow] will have been closed by this point *)</code></pre></header><nav class="odoc-toc"><ul><li><a href="#switch-creation">Switch creation</a></li><li><a href="#cancellation-and-failure">Cancellation and failure</a></li><li><a href="#cleaning-up-resources">Cleaning up resources</a></li><li><a href="#debugging">Debugging</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>A switch contains a group of fibers and other resources (such as open file handles).</p></div></div><h3 id="switch-creation"><a href="#switch-creation" class="anchor"></a>Switch creation</h3><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span><span class="optlabel">?name</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>run fn</code> runs <code>fn</code> with a fresh switch (initially on).</p><p>When <code>fn</code> finishes, <code>run</code> waits for all fibers registered with the switch to finish, and then releases all attached resources.</p><p>If <a href="#val-fail"><code>fail</code></a> is called, <code>run</code> will re-raise the exception (after everything is cleaned up). If <code>fn</code> raises an exception, it is passed to <a href="#val-fail"><code>fail</code></a>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">name</span> <p>Used to name the switch when tracing.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run_protected"><a href="#val-run_protected" class="anchor"></a><code><span><span class="keyword">val</span> run_protected : <span><span class="optlabel">?name</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>run_protected fn</code> is like <code>run</code> but ignores cancellation requests from the parent context.</p></div></div><h3 id="cancellation-and-failure"><a href="#cancellation-and-failure" class="anchor"></a>Cancellation and failure</h3><div class="odoc-spec"><div class="spec value anchored" id="val-check"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>check t</code> checks that <code>t</code> is still on.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../Cancel/index.html#exception-Cancelled"><code>Cancel.Cancelled</code></a> <p>If the switch has been cancelled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_error"><a href="#val-get_error" class="anchor"></a><code><span><span class="keyword">val</span> get_error : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn option</span></span></code></div><div class="spec-doc"><p><code>get_error t</code> is like <code>check t</code> except that it returns the exception instead of raising it. If <code>t</code> is finished, this returns (rather than raising) the <code>Invalid_argument</code> exception too.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span><span class="optlabel">?bt</span>:<span class="xref-unresolved">Stdlib</span>.Printexc.raw_backtrace <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fail t ex</code> adds <code>ex</code> to <code>t</code>'s set of failures and ensures that the switch's cancellation context is cancelled, to encourage all fibers to exit as soon as possible.</p><p><code>fail</code> returns immediately, without waiting for the shutdown actions to complete. The exception will be raised later by <a href="#val-run"><code>run</code></a>, and <code>run</code>'s caller is responsible for handling it. <a href="../Exn/index.html#val-combine"><code>Exn.combine</code></a> is used to avoid duplicate or unnecessary exceptions.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">bt</span> <p>A backtrace to attach to <code>ex</code></p></li></ul></div></div><h3 id="cleaning-up-resources"><a href="#cleaning-up-resources" class="anchor"></a>Cleaning up resources</h3><p>It is possible to attach clean-up hooks to a switch. Once all fibers within the switch have finished, these hooks are called. For example, when a file is opened it will register a release hook to close it.</p><p>Functions that create such resources will take a switch argument and call these functions for you. You usually don't need to call these directly.</p><div class="odoc-spec"><div class="spec value anchored" id="val-on_release"><a href="#val-on_release" class="anchor"></a><code><span><span class="keyword">val</span> on_release : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>on_release t fn</code> registers <code>fn</code> to be called once <code>t</code>'s main function has returned and all fibers have finished.</p><p>If <code>fn</code> raises an exception, it is passed to <a href="#val-fail"><code>fail</code></a>.</p><p>Release handlers are run in LIFO order, in series.</p><p>Note that <code>fn</code> is called within a <a href="../Cancel/index.html#val-protect"><code>Cancel.protect</code></a>, since aborting clean-up actions is usually a bad idea and the switch may have been cancelled by the time it runs. You cannot attach new resources to a switch once the cancel hooks start to run.</p><p>This function is thread-safe (but not signal-safe). If the switch finishes before <code>fn</code> can be registered, it raises <code>Invalid_argument</code> and runs <code>fn</code> immediately instead.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-hook"><a href="#type-hook" class="anchor"></a><code><span><span class="keyword">type</span> hook</span></code></div><div class="spec-doc"><p>A handle for removing a clean-up callback.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-null_hook"><a href="#val-null_hook" class="anchor"></a><code><span><span class="keyword">val</span> null_hook : <a href="#type-hook">hook</a></span></code></div><div class="spec-doc"><p>A dummy hook. <code>try_remove_hook null_hook = false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_release_cancellable"><a href="#val-on_release_cancellable" class="anchor"></a><code><span><span class="keyword">val</span> on_release_cancellable : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-hook">hook</a></span></code></div><div class="spec-doc"><p>Like <code>on_release</code>, but the handler can be removed later.</p><p>For example, opening a file will call <code>on_release_cancellable</code> to ensure the file is closed later. However, if the file is manually closed before that, it will use <a href="#val-remove_hook"><code>remove_hook</code></a> to remove the hook, which is no longer needed.</p><p>This function is thread-safe (but not signal-safe).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_remove_hook"><a href="#val-try_remove_hook" class="anchor"></a><code><span><span class="keyword">val</span> try_remove_hook : <span><a href="#type-hook">hook</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>try_remove_hook h</code> removes a previously-added hook. Returns <code>true</code> if the hook was successfully removed, or <code>false</code> if another domain ran it or removed it first.</p><p>This function is thread-safe (but not signal-safe).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_hook"><a href="#val-remove_hook" class="anchor"></a><code><span><span class="keyword">val</span> remove_hook : <span><a href="#type-hook">hook</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_hook h</code> is <code>ignore (try_remove_hook h)</code>.</p><p>For multi-domain code, consider using <a href="#val-try_remove_hook"><code>try_remove_hook</code></a> instead so that you can handle the case of trying to close a resource just as another domain is closing it or finishing the switch.</p></div></div><h3 id="debugging"><a href="#debugging" class="anchor"></a>Debugging</h3><div class="odoc-spec"><div class="spec value anchored" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span><span class="keyword">val</span> dump : <span><a href="#type-t">t</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p>Dump out details of the switch's state for debugging.</p></div></div></div></body></html>
