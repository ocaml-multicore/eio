<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mutex (eio.Eio.Mutex)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Mutex</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Mutex</span></code></h1><p>Mutual exclusion.</p><p>A mutex can be used to ensure that only one piece of code can access a shared resource at one time.</p><p>Unlike <code>Stdlib.Mutex</code>, which blocks the whole domain while waiting to take the mutex, this module allows other Eio fibers to run while waiting. You should use this module if your critical section may perform blocking operations, while <code>Stdlib.Mutex</code> may be more efficient if the lock is held only briefly and the critial section does not switch fibers.</p><p>Note that mutexes are often unnecessary for code running in a single domain, as the scheduler will only switch to another fiber if you perform an operation that can block.</p></header><nav class="odoc-toc"><ul><li><a href="#low-level-api">Low-level API</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../../Eio__/Eio_mutex/index.html#type-t">Mutex.t</a></span></code></div><div class="spec-doc"><p>The type for a concurrency-friendly mutex.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Poisoned"><a href="#exception-Poisoned" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Poisoned</span> <span class="keyword">of</span> exn</span></code></div><div class="spec-doc"><p>Raised if you attempt to use a mutex that has been disabled.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ()</code> creates an initially unlocked mutex.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-use_rw"><a href="#val-use_rw" class="anchor"></a><code><span><span class="keyword">val</span> use_rw : <span><span class="label">protect</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>use_rw ~protect t fn</code> waits for the mutex to be free and then executes <code>fn ()</code> while holding the mutex locked. <code>fn</code> may mutate the resource protected by the mutex, but must ensure the resource is in a consistent state before returning. If <code>fn</code> raises an exception, the mutex is disabled and cannot be used again.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">protect</span> <p>If <code>true</code>, uses <a href="../Cancel/index.html#val-protect"><code>Cancel.protect</code></a> to prevent the critical section from being cancelled. Cancellation is not prevented while waiting to take the lock.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-use_ro"><a href="#val-use_ro" class="anchor"></a><code><span><span class="keyword">val</span> use_ro : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>use_ro t fn</code> is like <code>use_rw ~protect:false</code>, but if <code>fn</code> raises an exception it unlocks the mutex instead of disabling it. Use this if you only need read-only access to the mutex's resource and so know that it will be in a consistent state even if an exception is raised.</p><p>Note: a mutex still only allows one fiber to have the mutex locked at a time, even if all operations are &quot;read-only&quot;.</p></div></div><h3 id="low-level-api"><a href="#low-level-api" class="anchor"></a>Low-level API</h3><p>Care must be taken when locking a mutex manually. It is easy to forget to unlock it in some cases, which will result in deadlock the next time a fiber tries to use it. In particular, you need to consider:</p><ul><li>What happens if your critical section raises an exception.</li><li>What happens if your fiber is cancelled while in its critical section.</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-lock"><a href="#val-lock" class="anchor"></a><code><span><span class="keyword">val</span> lock : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Lock the given mutex. Only one fiber can have the mutex locked at any time. A fiber that attempts to lock a mutex already locked by another fiber will suspend until the other fiber unlocks the mutex. If no other fiber has the lock, this returns immediately without switching fibers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unlock"><a href="#val-unlock" class="anchor"></a><code><span><span class="keyword">val</span> unlock : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unlock t</code> unlocks the mutex.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Sys_error</code> <p>if the mutex is unlocked.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_lock"><a href="#val-try_lock" class="anchor"></a><code><span><span class="keyword">val</span> try_lock : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-lock"><code>lock</code></a>, but does not suspend the calling thread if the mutex is already locked: just return <code>false</code> immediately in that case. If the mutex is unlocked, lock it and return <code>true</code>.</p></div></div></div></body></html>
