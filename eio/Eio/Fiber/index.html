<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fiber (eio.Eio.Fiber)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Fiber</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Fiber</span></code></h1><p>A fiber is a light-weight thread.</p><p>Within a domain, only one fiber can be running at a time. A fiber runs until it performs an IO operation (directly or indirectly). At that point, it may be suspended and the next fiber on the run queue runs.</p></header><nav class="odoc-toc"><ul><li><a href="#fiber-local-variables">Fiber-local variables</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-both"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>both f g</code> runs <code>f ()</code> and <code>g ()</code> concurrently.</p><p>They run in a new cancellation sub-context, and if either raises an exception, the other is cancelled. <code>both</code> waits for both functions to finish even if one raises (it will then re-raise the original exception).</p><p><code>f</code> runs immediately, without switching to any other thread. <code>g</code> is inserted at the head of the run-queue, so it runs next even if other threads are already enqueued. You can get other scheduling orders by adding calls to <a href="#val-yield"><code>yield</code></a> in various places. e.g. to append both fibers to the end of the run-queue, yield immediately before calling <code>both</code>.</p><p>If both fibers fail, <a href="../Exn/index.html#val-combine"><code>Exn.combine</code></a> is used to combine the exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pair"><a href="#val-pair" class="anchor"></a><code><span><span class="keyword">val</span> pair : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>pair f g</code> is like <code>both</code>, but returns the two results.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>all fs</code> is like <code>both</code>, but for any number of fibers. <code>all []</code> returns immediately.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span class="optlabel">?combine</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>first f g</code> runs <code>f ()</code> and <code>g ()</code> concurrently.</p><p>They run in a new cancellation sub-context, and when one finishes the other is cancelled. If one raises, the other is cancelled and the exception is reported.</p><p>As with <code>both</code>, <code>f</code> runs immediately and <code>g</code> is scheduled next, ahead of any other queued work.</p><p>If both fibers fail, <a href="../Exn/index.html#val-combine"><code>Exn.combine</code></a> is used to combine the exceptions.</p><p>Warning: it is always possible that <i>both</i> operations will succeed. This is because there is a period of time after the first operation succeeds when it is waiting in the run-queue to resume during which the other operation may also succeed.</p><p>If both fibers succeed, <code>combine a b</code> is used to combine the results (where <code>a</code> is the result of the first fiber to return and <code>b</code> is the second result). The default is <code>fun a _ -&gt; a</code>, which discards the later result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span><span class="optlabel">?combine</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>any fs</code> is like <code>first</code>, but for any number of fibers.</p><p><code>any []</code> just waits forever (or until cancelled).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-n_any"><a href="#val-n_any" class="anchor"></a><code><span><span class="keyword">val</span> n_any : <span><span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>n_any fs</code> is like <code>any</code>, expect that if multiple fibers return values then they are all returned, in the order in which the fibers finished.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_cancel"><a href="#val-await_cancel" class="anchor"></a><code><span><span class="keyword">val</span> await_cancel : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>await_cancel ()</code> waits until cancelled.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../Cancel/index.html#exception-Cancelled"><code>Cancel.Cancelled</code></a> </li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fork"><a href="#val-fork" class="anchor"></a><code><span><span class="keyword">val</span> fork : <span><span class="label">sw</span>:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fork ~sw fn</code> runs <code>fn ()</code> in a new fiber, but does not wait for it to complete.</p><p>The new fiber is attached to <code>sw</code> (which can't finish until the fiber ends).</p><p>The new fiber inherits <code>sw</code>'s cancellation context. If the fiber raises an exception, <code>Switch.fail sw</code> is called. If <code>sw</code> is already off then <code>fn</code> fails immediately, but the calling thread continues.</p><p><code>fn</code> runs immediately, without switching to any other fiber first. The calling fiber is placed at the head of the run queue, ahead of any previous items.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fork_promise"><a href="#val-fork_promise" class="anchor"></a><code><span><span class="keyword">val</span> fork_promise : <span><span class="label">sw</span>:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Promise/index.html#type-or_exn">Promise.or_exn</a></span></span></code></div><div class="spec-doc"><p><code>fork_promise ~sw fn</code> schedules <code>fn ()</code> to run in a new fiber and returns a promise for its result.</p><p>This is just a convenience wrapper around <a href="#val-fork"><code>fork</code></a>. If <code>fn</code> raises an exception then the promise is resolved to the error, but <code>sw</code> is not failed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fork_seq"><a href="#val-fork_seq" class="anchor"></a><code><span><span class="keyword">val</span> fork_seq : <span><span class="label">sw</span>:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>fork_seq ~sw fn</code> creates (but does not start) a new fiber to run <code>fn yield</code>.</p><p>Requesting the next item from the returned sequence resumes the fiber until it calls <code>yield x</code>, using <code>x</code> value as the next item in the sequence. If <code>fn</code> returns without producing a value then the result is <code>Seq.Nil</code> (end-of-sequence).</p><p>The returned sequence can be consumed safely from another domain. <code>fn</code> itself always runs in the domain that called <code>fork_seq</code>.</p><p>Example:</p><pre class="language-ocaml"><code>Switch.run @@ fun sw -&gt;
let seq = Fiber.fork_seq ~sw (fun yield -&gt;
    for i = 1 to 3 do
      traceln &quot;Yielding %d&quot; i;
      yield i
    done
  ) in
Seq.iter (traceln &quot;Got: %d&quot;) seq</code></pre><p>If <code>fn</code> raises an exception then the consumer receives it. If the consumer cancels while awaiting a value, the producer is cancelled when it next calls <code>yield</code>. It is an error to request two items at once, or to request items out of sequence.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">sw</span> <p>When the switch finishes, the fiber is cancelled (if still running). Attempting to read from the sequence after this raises an exception.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fork_daemon"><a href="#val-fork_daemon" class="anchor"></a><code><span><span class="keyword">val</span> fork_daemon : <span><span class="label">sw</span>:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>[ `Stop_daemon ]</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fork_daemon</code> is like <a href="#val-fork"><code>fork</code></a> except that instead of waiting for the fiber to finish, the switch will cancel it once all non-daemon fibers are done.</p><p>The switch will still wait for the daemon fiber to finish cancelling.</p><p>The return type of <code>[`Stop_daemon]</code> instead of <code>unit</code> is just to catch mistakes, as daemons normally aren't expected to return.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>check ()</code> checks that the fiber's context hasn't been cancelled. Many operations automatically check this before starting.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../Cancel/index.html#exception-Cancelled"><code>Cancel.Cancelled</code></a> <p>if the fiber's context has been cancelled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_cancelled"><a href="#val-is_cancelled" class="anchor"></a><code><span><span class="keyword">val</span> is_cancelled : <span>unit <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_cancelled ()</code> is <code>true</code> iff <a href="#val-check"><code>check</code></a> would raise an exception.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield ()</code> asks the scheduler to switch to the next runnable task. The current task remains runnable, but goes to the back of the queue. Automatically calls <a href="#val-check"><code>check</code></a> just before resuming.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-List"><a href="#module-List" class="anchor"></a><code><span><span class="keyword">module</span> <a href="List/index.html">List</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Concurrent list operations.</p></div></div><h3 id="fiber-local-variables"><a href="#fiber-local-variables" class="anchor"></a>Fiber-local variables</h3><p>Each fiber maintains a map of additional variables associated with it, which can be used to store fiber-related state or context. This map is propagated to any forked fibers.</p><p>While fiber-local variables can be useful, they can also make code much harder to reason about, as they effectively act as another form of global state. When possible, prefer passing arguments around explicitly.</p><p>Fiber-local variables are particularly useful for attaching extra information for debugging, such as a request ID that the log system can include in all logged messages.</p><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a key</span></span></code></div><div class="spec-doc"><p><code>'a key</code> is a fiber-local variable of type <code>'a</code>.</p><p>Since the key is required to get or set a variable, a library can keep its key private to control how the variable can be accessed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_key"><a href="#val-create_key" class="anchor"></a><code><span><span class="keyword">val</span> create_key : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-key">key</a></span></span></code></div><div class="spec-doc"><p><code>create_key ()</code> creates a new fiber-local variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>get key</code> reads <code>key</code> from the map of fiber local variables, returning its value or <code>None</code> if it has not been bound.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_binding"><a href="#val-with_binding" class="anchor"></a><code><span><span class="keyword">val</span> with_binding : <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>with_binding key value fn</code> runs <code>fn</code> with <code>key</code> bound to the provided <code>value</code>.</p><p>Whilst this binding only exists for the duration of this function <i>on this fiber</i>, it will be propagated to any forked fibers. If <code>fn</code> creates fibers using an external switch, the bound value may be continue to be used after this function returns.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-without_binding"><a href="#val-without_binding" class="anchor"></a><code><span><span class="keyword">val</span> without_binding : <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>with_binding key value fn</code> runs <code>fn</code> with any binding for <code>key</code> removed.</p></div></div></div></body></html>
