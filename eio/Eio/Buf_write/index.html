<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Buf_write (eio.Eio.Buf_write)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Buf_write</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Buf_write</span></code></h1><p>Buffered output</p><p>Serialization primitives built for speed and memory-efficiency.</p><p>Buf_write is designed for writing fast and memory-efficient serializers. It is based on the Faraday library, but adapted for Eio. Its core type and related operation gives the user fine-grained control over copying and allocation behavior while serializing user-defined types, and presents the output in a form that makes it possible to use vectorized write operations, such as the <code>writev</code> system call, or any other platform or application-specific output APIs.</p><p>A Buf_write serializer manages an internal buffer and a queue of output buffers. The output bufferes may be a sub range of the serializer's internal buffer or one that is user-provided. Buffered writes such as <a href="#val-string"><code>string</code></a>, <a href="#val-char"><code>char</code></a>, <a href="#val-cstruct"><code>cstruct</code></a>, etc., copy the source bytes into the serializer's internal buffer. Unbuffered writes are done with <a href="#val-schedule_cstruct"><code>schedule_cstruct</code></a>, which performs no copying. Instead, it enqueues the source bytes into the serializer's write queue directly.</p><p>Example:</p><pre class="language-ocaml"><code>module Write = Eio.Buf_write

let () =
    Eio_mock.Backend.run @@ fun () -&gt;
    let stdout = Eio_mock.Flow.make &quot;stdout&quot; in
    Write.with_flow stdout (fun w -&gt;
        Write.string w &quot;foo&quot;;
        Write.string w &quot;bar&quot;;
        Eio.Fiber.yield ();
        Write.string w &quot;baz&quot;;
    )</code></pre><p>This combines the first two writes, giving:</p><pre class="language-ocaml"><code>+stdout: wrote &quot;foobar&quot;
+stdout: wrote &quot;baz&quot;</code></pre></header><nav class="odoc-toc"><ul><li><a href="#running">Running</a></li><li><a href="#buffered-writes">Buffered Writes</a></li><li><a href="#unbuffered-writes">Unbuffered Writes</a></li><li><a href="#querying-a-serializer's-state">Querying A Serializer's State</a></li><li><a href="#control-operations">Control Operations</a></li><li><a href="#low-level-api">Low-level API</a></li><li><a href="#convenience-functions">Convenience Functions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of a serializer.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Flush_aborted"><a href="#exception-Flush_aborted" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Flush_aborted</span></span></code></div><div class="spec-doc"><p>Raised when waiting for a flush to complete if the buffer is destroyed instead.</p></div></div><h3 id="running"><a href="#running" class="anchor"></a>Running</h3><div class="odoc-spec"><div class="spec value anchored" id="val-with_flow"><a href="#val-with_flow" class="anchor"></a><code><span><span class="keyword">val</span> with_flow : <span>?initial_size:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="../Flow/index.html#type-sink">Flow.sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_flow flow fn</code> runs <code>fn writer</code>, where <code>writer</code> is a buffer that flushes to <code>flow</code>.</p><p>Concurrently with <code>fn</code>, it also runs a fiber that copies from <code>writer</code> to <code>flow</code>. If this fiber runs out of data to copy then it will suspend itself. Writing to <code>writer</code> will automatically schedule it to be resumed. This means that pending data is flushed automatically before the process sleeps.</p><p>When <code>fn</code> returns, <code>writer</code> is automatically closed and any remaining data is flushed before <code>with_flow</code> itself returns.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">initial_size</span> <p>The initial size of the buffer used to collect writes. New buffers will be allocated as needed, with the same size. If the buffer is too small to contain a write, the size is increased.</p></li></ul></div></div><h3 id="buffered-writes"><a href="#buffered-writes" class="anchor"></a>Buffered Writes</h3><p>A serializer manages an internal buffer for coalescing small writes. The size of this buffer is determined when the serializer is created. If the buffer does not contain sufficient space to service a caller's buffered write, the serializer will allocate a new buffer of the sufficient size and use it for the current and subsequent writes. The old buffer will be garbage collected once all of its contents have been <a href="#val-flush"><code>flush</code></a>ed.</p><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>string t ?off ?len str</code> copies <code>str</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>bytes t ?off ?len bytes</code> copies <code>bytes</code> into the serializer's internal buffer. It is safe to modify <code>bytes</code> after this call returns.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cstruct"><a href="#val-cstruct" class="anchor"></a><code><span><span class="keyword">val</span> cstruct : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cstruct t cs</code> copies <code>cs</code> into the serializer's internal buffer. It is safe to modify <code>cs</code> after this call returns. For large cstructs, it may be more efficient to use <a href="#val-schedule_cstruct"><code>schedule_cstruct</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_gen"><a href="#val-write_gen" class="anchor"></a><code><span><span class="keyword">val</span> write_gen : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>blit:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.buffer <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>off:int <span class="arrow">&#45;&gt;</span></span>
  <span>len:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>write_gen t ~blit ~off ~len x</code> copies <code>x</code> into the serializer's internal buffer using the provided <code>blit</code> operation. See <code>Bigstring</code>.blit for documentation of the arguments.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-char"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>char t c</code> copies <code>c</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint8"><a href="#val-uint8" class="anchor"></a><code><span><span class="keyword">val</span> uint8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>uint8 t n</code> copies the lower 8 bits of <code>n</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-BE"><a href="#module-BE" class="anchor"></a><code><span><span class="keyword">module</span> <a href="BE/index.html">BE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Big endian serializers</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-LE"><a href="#module-LE" class="anchor"></a><code><span><span class="keyword">module</span> <a href="LE/index.html">LE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Little endian serializers</p></div></div><h3 id="unbuffered-writes"><a href="#unbuffered-writes" class="anchor"></a>Unbuffered Writes</h3><p>Unbuffered writes do not involve copying bytes to the serializer's internal buffer.</p><div class="odoc-spec"><div class="spec value anchored" id="val-schedule_cstruct"><a href="#val-schedule_cstruct" class="anchor"></a><code><span><span class="keyword">val</span> schedule_cstruct : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>schedule_cstruct t cs</code> schedules <code>cs</code> to be written. <code>cs</code> is not copied in this process, so <code>cs</code> should only be modified after <code>t</code> has been <a href="#val-flush"><code>flush</code></a>ed.</p></div></div><h3 id="querying-a-serializer's-state"><a href="#querying-a-serializer's-state" class="anchor"></a>Querying A Serializer's State</h3><div class="odoc-spec"><div class="spec value anchored" id="val-free_bytes_in_buffer"><a href="#val-free_bytes_in_buffer" class="anchor"></a><code><span><span class="keyword">val</span> free_bytes_in_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>free_bytes_in_buffer t</code> returns the free space, in bytes, of the serializer's write buffer. If a write call has a length that exceeds this value, the serializer will allocate a new buffer that will replace the serializer's internal buffer for that and subsequent calls.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_pending_output"><a href="#val-has_pending_output" class="anchor"></a><code><span><span class="keyword">val</span> has_pending_output : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_pending_output t</code> is <code>true</code> if <code>t</code>'s output queue is non-empty. It may be the case that <code>t</code>'s queued output is being serviced by some other thread of control, but has not yet completed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pending_bytes"><a href="#val-pending_bytes" class="anchor"></a><code><span><span class="keyword">val</span> pending_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>pending_bytes t</code> is the size of the next write, in bytes, that <code>t</code> will surface to the caller via <a href="#val-await_batch"><code>await_batch</code></a>.</p></div></div><h3 id="control-operations"><a href="#control-operations" class="anchor"></a>Control Operations</h3><div class="odoc-spec"><div class="spec value anchored" id="val-pause"><a href="#val-pause" class="anchor"></a><code><span><span class="keyword">val</span> pause : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pause t</code> causes <code>t</code> to stop surfacing writes to the user. This gives the serializer an opportunity to collect additional writes before sending them to the underlying device, which will increase the write batch size.</p><p>As one example, code may want to call this function if it's about to release the OCaml lock and perform a blocking system call, but would like to batch output across that system call.</p><p>Call <a href="#val-unpause"><code>unpause</code></a> to resume writing later. Note that calling <a href="#val-flush"><code>flush</code></a> or <a href="#val-close"><code>close</code></a> will automatically call <a href="#val-unpause"><code>unpause</code></a> too.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unpause"><a href="#val-unpause" class="anchor"></a><code><span><span class="keyword">val</span> unpause : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unpause t</code> resumes writing data after a previous call to <a href="#val-pause"><code>pause</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>flush t</code> waits until all prior writes have been successfully completed. If <code>t</code> has no pending writes, <code>flush</code> returns immediately. If <code>t</code> is paused then it is unpaused first.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Flush_aborted</span> <p>if <a href="#val-abort"><code>abort</code></a> is called before the data is written.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close t</code> closes <code>t</code>. All subsequent write calls will raise, and any subsequent <a href="#val-pause"><code>pause</code></a> calls will be ignored. If the serializer has any pending writes, user code will have an opportunity to service them before receiving <code>End_of_file</code>. Flush callbacks will continue to be invoked while output is <a href="#val-shift"><code>shift</code></a>ed out of <code>t</code> as needed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> is <code>true</code> if <code>close</code> has been called on <code>t</code> and <code>false</code> otherwise. A closed <code>t</code> may still have pending output.</p></div></div><h3 id="low-level-api"><a href="#low-level-api" class="anchor"></a>Low-level API</h3><p>Low-level operations for running a serializer.</p><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>?sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ~sw len</code> creates a serializer with a fixed-length internal buffer of length <code>len</code>. See the Buffered writes section for details about what happens when <code>len</code> is not large enough to support a write.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">sw</span> <p>When the switch is finished, <a href="#val-abort"><code>abort</code></a> is called. If you don't pass a switch, you may want to call <code>abort</code> manually on error.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_buffer"><a href="#val-of_buffer" class="anchor"></a><code><span><span class="keyword">val</span> of_buffer : <span>?sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.buffer <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_buffer ~sw buf</code> creates a serializer, using <code>buf</code> as its internal buffer. The serializer takes ownership of <code>buf</code> until the serializer has been closed and flushed of all output.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abort"><a href="#val-abort" class="anchor"></a><code><span><span class="keyword">val</span> abort : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>abort t</code> is like <a href="#val-close"><code>close</code></a> followed by <a href="#val-drain"><code>drain</code></a>, except that any pending flush operations fail instead of completing successfully.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_batch"><a href="#val-await_batch" class="anchor"></a><code><span><span class="keyword">val</span> await_batch : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t list</span></span></code></div><div class="spec-doc"><p><code>await_batch t</code> returns a list of buffers that should be written. If no data is currently available, it waits until some is. After performing a write, call <a href="#val-shift"><code>shift</code></a> with the number of bytes written. You must accurately report the number of bytes written. Failure to do so will result in the same bytes being surfaced multiple times.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p><code>t</code> is closed and there is nothing left to write.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span><span class="keyword">val</span> shift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>shift t n</code> removes the first <code>n</code> bytes in <code>t</code>'s write queue. Any flush operations called within this span of the write queue will be scheduled to resume.</p></div></div><h3 id="convenience-functions"><a href="#convenience-functions" class="anchor"></a>Convenience Functions</h3><p>These functions are included for testing, debugging, and general development. They are not the suggested way of driving a serializer in a production setting.</p><div class="odoc-spec"><div class="spec value anchored" id="val-serialize"><a href="#val-serialize" class="anchor"></a><code><span><span class="keyword">val</span> serialize : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int, <span>[ `Closed ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit, <span>[&gt; `Closed ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>serialize t writev</code> calls <code>writev bufs</code> each time <code>t</code> is ready to write. In the event that <code>writev</code> indicates a partial write, <a href="#val-serialize"><code>serialize</code></a> will call <a href="../Fiber/index.html#val-yield"><code>Fiber.yield</code></a> before continuing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-serialize_to_string"><a href="#val-serialize_to_string" class="anchor"></a><code><span><span class="keyword">val</span> serialize_to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>serialize_to_string t</code> runs <code>t</code>, collecting the output into a string and returning it. <code>serializie_to_string t</code> immediately closes <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-serialize_to_cstruct"><a href="#val-serialize_to_cstruct" class="anchor"></a><code><span><span class="keyword">val</span> serialize_to_cstruct : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Cstruct</span>.t</span></code></div><div class="spec-doc"><p><code>serialize_to_cstruct t</code> runs <code>t</code>, collecting the output into a cstruct and returning it. <code>serialize_to_cstruct t</code> immediately closes <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span><span class="keyword">val</span> drain : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>drain t</code> removes all pending writes from <code>t</code>, returning the number of bytes that were enqueued to be written and freeing any scheduled buffers in the process. Note that this does not close <code>t</code> itself, and does not return until <code>t</code> has been closed.</p></div></div></div></body></html>