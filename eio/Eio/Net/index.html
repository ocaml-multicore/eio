<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Net (eio.Eio.Net)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Net</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Net</span></code></h1><p>Networking.</p><p>Example:</p><pre class="language-ocaml"><code>let addr = `Tcp (Ipaddr.V4.loopback, 8080)

let http_get ~net ~stdout addr =
  Switch.run @@ fun sw -&gt;
  let flow = Net.connect ~sw net addr in
  Flow.copy_string &quot;GET / HTTP/1.0\r\n\r\n&quot; flow;
  Flow.shutdown flow `Send;
  Flow.copy flow stdout</code></pre></header><nav class="odoc-toc"><ul><li><a href="#provider-interfaces">Provider Interfaces</a></li><li><a href="#out-bound-connections">Out-bound Connections</a></li><li><a href="#incoming-connections">Incoming Connections</a></li><li><a href="#running-servers">Running Servers</a></li><li><a href="#datagram-sockets">Datagram Sockets</a></li><li><a href="#dns-queries">DNS queries</a></li><li><a href="#closing">Closing</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-connection_failure"><a href="#type-connection_failure" class="anchor"></a><code><span><span class="keyword">type</span> connection_failure</span><span> = </span></code><ol><li id="type-connection_failure.Refused" class="def variant constructor anchored"><a href="#type-connection_failure.Refused" class="anchor"></a><code><span>| </span><span><span class="constructor">Refused</span> <span class="keyword">of</span> <a href="../Exn/Backend/index.html#type-t">Exn.Backend.t</a></span></code></li><li id="type-connection_failure.No_matching_addresses" class="def variant constructor anchored"><a href="#type-connection_failure.No_matching_addresses" class="anchor"></a><code><span>| </span><span><span class="constructor">No_matching_addresses</span></span></code></li><li id="type-connection_failure.Timeout" class="def variant constructor anchored"><a href="#type-connection_failure.Timeout" class="anchor"></a><code><span>| </span><span><span class="constructor">Timeout</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span></code><ol><li id="type-error.Connection_reset" class="def variant constructor anchored"><a href="#type-error.Connection_reset" class="anchor"></a><code><span>| </span><span><span class="constructor">Connection_reset</span> <span class="keyword">of</span> <a href="../Exn/Backend/index.html#type-t">Exn.Backend.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This is a wrapper for epipe, econnreset and similar errors. It indicates that the flow has failed, and data may have been lost.</p><span class="comment-delim">*)</span></div></li><li id="type-error.Connection_failure" class="def variant constructor anchored"><a href="#type-error.Connection_failure" class="anchor"></a><code><span>| </span><span><span class="constructor">Connection_failure</span> <span class="keyword">of</span> <a href="#type-connection_failure">connection_failure</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-E"><a href="#extension-decl-E" class="anchor"></a><code><span><span class="keyword">type</span> <a href="../Exn/index.html#type-err">Exn.err</a> += </span></code><ol><li id="extension-E" class="def extension anchored"><a href="#extension-E" class="anchor"></a><code><span>| </span><span><span class="extension">E</span> <span class="keyword">of</span> <a href="#type-error">error</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-err"><a href="#val-err" class="anchor"></a><code><span><span class="keyword">val</span> err : <span><a href="#type-error">error</a> <span class="arrow">&#45;&gt;</span></span> exn</span></code></div><div class="spec-doc"><p><code>err e</code> is <code>Eio.Exn.create (Net e)</code></p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Ipaddr"><a href="#module-Ipaddr" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ipaddr/index.html">Ipaddr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>IP addresses.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Sockaddr"><a href="#module-Sockaddr" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sockaddr/index.html">Sockaddr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Network addresses.</p></div></div><h3 id="provider-interfaces"><a href="#provider-interfaces" class="anchor"></a>Provider Interfaces</h3><div class="odoc-spec"><div class="spec class anchored" id="class-socket"><a href="#class-socket" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span>  </span><span><a href="class-socket/index.html">socket</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-stream_socket"><a href="#class-stream_socket" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span>  </span><span><a href="class-stream_socket/index.html">stream_socket</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-datagram_socket"><a href="#class-datagram_socket" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span>  </span><span><a href="class-datagram_socket/index.html">datagram_socket</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-listening_socket"><a href="#class-listening_socket" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span>  </span><span><a href="class-listening_socket/index.html">listening_socket</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-t"><a href="#class-t" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span>  </span><span><a href="class-t/index.html">t</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="out-bound-connections"><a href="#out-bound-connections" class="anchor"></a>Out-bound Connections</h3><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-stream">Sockaddr.stream</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Eio__Net/class-stream_socket/index.html">stream_socket</a></span></code></div><div class="spec-doc"><p><code>connect ~sw t addr</code> is a new socket connected to remote address <code>addr</code>.</p><p>The new socket will be closed when <code>sw</code> finishes, unless closed manually first.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_tcp_connect"><a href="#val-with_tcp_connect" class="anchor"></a><code><span><span class="keyword">val</span> with_tcp_connect : 
  <span>?timeout:<a href="../Time/Timeout/index.html#type-t">Time.Timeout.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>host:string <span class="arrow">&#45;&gt;</span></span>
  <span>service:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../Eio__Net/class-stream_socket/index.html">stream_socket</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>with_tcp_connect ~host ~service t f</code> creates a tcp connection <code>conn</code> to <code>host</code> and <code>service</code> and executes <code>f conn</code>.</p><p><code>conn</code> is closed after <code>f</code> returns (if it isn't already closed by then).</p><p><code>host</code> is either an IP address or a domain name, eg. &quot;www.example.org&quot;, &quot;www.ocaml.org&quot; or &quot;127.0.0.1&quot;.</p><p><code>service</code> is an IANA recognized service name or port number, eg. &quot;http&quot;, &quot;ftp&quot;, &quot;8080&quot; etc. See https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.</p><p>Addresses are tried in the order they are returned by <a href="#val-getaddrinfo"><code>getaddrinfo</code></a>, until one succeeds.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">timeout</span> <p>Limits how long to wait for each connection attempt before moving on to the next. By default there is no timeout (beyond what the underlying network does).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Connection_failure</span> <p>A connection couldn't be established for any of the addresses defined for <code>host</code>.</p></li></ul></div></div><h3 id="incoming-connections"><a href="#incoming-connections" class="anchor"></a>Incoming Connections</h3><div class="odoc-spec"><div class="spec value anchored" id="val-listen"><a href="#val-listen" class="anchor"></a><code><span><span class="keyword">val</span> listen : 
  <span>?reuse_addr:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?reuse_port:bool <span class="arrow">&#45;&gt;</span></span>
  <span>backlog:int <span class="arrow">&#45;&gt;</span></span>
  <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Sockaddr/index.html#type-stream">Sockaddr.stream</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Eio__Net/class-listening_socket/index.html">listening_socket</a></span></code></div><div class="spec-doc"><p><code>listen ~sw ~backlog t addr</code> is a new listening socket bound to local address <code>addr</code>.</p><p>The new socket will be closed when <code>sw</code> finishes, unless closed manually first.</p><p>For (non-abstract) Unix domain sockets, the path will be removed afterwards.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">backlog</span> <p>The number of pending connections that can be queued up (see listen(2)).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">reuse_addr</span> <p>Set the <code>Unix</code>.SO_REUSEADDR socket option. For Unix paths, also remove any stale left-over socket.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">reuse_port</span> <p>Set the <code>Unix</code>.SO_REUSEPORT socket option.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-accept"><a href="#val-accept" class="anchor"></a><code><span><span class="keyword">val</span> accept : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="class-listening_socket/index.html">listening_socket</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Eio__Net/class-stream_socket/index.html">stream_socket</a> * <a href="Sockaddr/index.html#type-stream">Sockaddr.stream</a></span></code></div><div class="spec-doc"><p><code>accept ~sw socket</code> waits until a new connection is ready on <code>socket</code> and returns it.</p><p>The new socket will be closed automatically when <code>sw</code> finishes, if not closed earlier. If you want to handle multiple connections, consider using <a href="#val-accept_fork"><code>accept_fork</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-connection_handler"><a href="#type-connection_handler" class="anchor"></a><code><span><span class="keyword">type</span> connection_handler</span><span> = <span><a href="../../Eio__Net/class-stream_socket/index.html">stream_socket</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-stream">Sockaddr.stream</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>connection_handler</code> handles incoming connections from a listening socket.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-accept_fork"><a href="#val-accept_fork" class="anchor"></a><code><span><span class="keyword">val</span> accept_fork : 
  <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="class-listening_socket/index.html">listening_socket</a> <span class="arrow">&#45;&gt;</span></span>
  <span>on_error:<span>(<span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-connection_handler">connection_handler</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>accept_fork ~sw ~on_error socket fn</code> accepts a connection and handles it in a new fiber.</p><p>After accepting a connection to <code>socket</code>, it runs <code>fn flow client_addr</code> in a new fiber.</p><p><code>flow</code> will be closed when <code>fn</code> returns. The new fiber is attached to <code>sw</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">on_error</span> <p>Called if <code>connection_handler</code> raises an exception. This is typically a good place to log the error and continue. If the exception is an <a href="../index.html#exception-Io"><code>Eio.Io</code></a> error then the caller's address is added to it.</p><p>If you don't want to handle connection errors, use <code>~on_error:raise</code> to cancel the caller's context.</p><p><code>on_error</code> is not called for <a href="../Cancel/index.html#exception-Cancelled"><code>Cancel.Cancelled</code></a> exceptions, which do not need to be reported.</p></li></ul></div></div><h3 id="running-servers"><a href="#running-servers" class="anchor"></a>Running Servers</h3><div class="odoc-spec"><div class="spec value anchored" id="val-run_server"><a href="#val-run_server" class="anchor"></a><code><span><span class="keyword">val</span> run_server : 
  <span>?max_connections:int <span class="arrow">&#45;&gt;</span></span>
  <span>?additional_domains:<span>(<a href="../Domain_manager/class-t/index.html">Domain_manager.t</a> * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?stop:<span><span class="type-var">'a</span> <a href="../Promise/index.html#type-t">Promise.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>on_error:<span>(<span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="class-listening_socket/index.html">listening_socket</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-connection_handler">connection_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>run_server ~on_error sock connection_handler</code> establishes a concurrent socket server <code>s</code>.</p><p>It accepts incoming client connections on socket <code>sock</code> and handles them with <a href="#val-accept_fork"><code>accept_fork</code></a> (see that for the description of <code>on_error</code> and <code>connection_handler</code>).</p><p><b>Running a Parallel Server</b></p><p>By default <code>s</code> runs on a <em>single</em> OCaml <code>Domain</code>. However, if <code>additional_domains:(domain_mgr, domains)</code> parameter is given, then <code>s</code> will spawn <code>domains</code> additional domains and run accept loops in those too. In such cases you must ensure that <code>connection_handler</code> only accesses thread-safe values. Note that having more than <code>Domain</code>.recommended_domain_count domains in total is likely to result in bad performance.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_connections</span> <p>The maximum number of concurrent connections accepted by <code>s</code> at any time. The default is <code>Int.max_int</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stop</span> <p>Resolving this promise causes <code>s</code> to stop accepting new connections. <code>run_server</code> will wait for all existing connections to finish and then return. This is useful to upgrade a server without clients noticing. To stop immediately, cancelling all connections, just cancel <code>s</code>'s fiber instead.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">on_error</span> <p>Connection error handler (see <a href="#val-accept_fork"><code>accept_fork</code></a>).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>max_connections &lt;= 0</code>. if <code>additional_domains = (domain_mgr, domains)</code> is used and <code>domains &lt; 0</code>.</p></li></ul></div></div><h3 id="datagram-sockets"><a href="#datagram-sockets" class="anchor"></a>Datagram Sockets</h3><div class="odoc-spec"><div class="spec value anchored" id="val-datagram_socket"><a href="#val-datagram_socket" class="anchor"></a><code><span><span class="keyword">val</span> datagram_socket : 
  <span>?reuse_addr:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?reuse_port:bool <span class="arrow">&#45;&gt;</span></span>
  <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[&lt; <a href="Sockaddr/index.html#type-datagram">Sockaddr.datagram</a> <span>| `UdpV4</span> <span>| `UdpV6</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Eio__Net/class-datagram_socket/index.html">datagram_socket</a></span></code></div><div class="spec-doc"><p><code>datagram_socket ~sw t addr</code> creates a new datagram socket bound to <code>addr</code>. The new socket will be closed when <code>sw</code> finishes.</p><p><code>`UdpV4</code> and <code>`UdpV6</code> represents IPv4 and IPv6 datagram client sockets where the OS assigns the next available socket address and port automatically. <code>`Udp ..</code> can be used to create both listening server socket and client socket.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">reuse_addr</span> <p>Set the <code>Unix</code>.SO_REUSEADDR socket option.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">reuse_port</span> <p>Set the <code>Unix</code>.SO_REUSEPORT socket option.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-send"><a href="#val-send" class="anchor"></a><code><span><span class="keyword">val</span> send : <span><a href="class-datagram_socket/index.html">datagram_socket</a> <span class="arrow">&#45;&gt;</span></span> <span>?dst:<a href="Sockaddr/index.html#type-datagram">Sockaddr.datagram</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>send sock buf</code> sends the data in <code>buf</code> using the the datagram socket <code>sock</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">dst</span> <p>If <code>sock</code> isn't connected, this provides the destination.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-recv"><a href="#val-recv" class="anchor"></a><code><span><span class="keyword">val</span> recv : <span><a href="class-datagram_socket/index.html">datagram_socket</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> <a href="Sockaddr/index.html#type-datagram">Sockaddr.datagram</a> * int</span></code></div><div class="spec-doc"><p><code>recv sock buf</code> receives data from the socket <code>sock</code> putting it in <code>buf</code>. The number of bytes received is returned along with the sender address and port. If the <code>buf</code> is too small then excess bytes may be discarded depending on the type of the socket the message is received from.</p></div></div><h3 id="dns-queries"><a href="#dns-queries" class="anchor"></a>DNS queries</h3><div class="odoc-spec"><div class="spec value anchored" id="val-getaddrinfo"><a href="#val-getaddrinfo" class="anchor"></a><code><span><span class="keyword">val</span> getaddrinfo : <span>?service:string <span class="arrow">&#45;&gt;</span></span> <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-t">Sockaddr.t</a> list</span></span></code></div><div class="spec-doc"><p><code>getaddrinfo ?service t node</code> returns a list of IP addresses for <code>node</code>. <code>node</code> is either a domain name or an IP address.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">service</span> <p>is a human friendly textual name for internet services assigned by IANA., eg. 'http', 'https', 'ftp', etc.</p><p>For a more thorough treatment, see <a href="https://man7.org/linux/man-pages/man3/getaddrinfo.3.html">getaddrinfo</a>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-getaddrinfo_stream"><a href="#val-getaddrinfo_stream" class="anchor"></a><code><span><span class="keyword">val</span> getaddrinfo_stream : <span>?service:string <span class="arrow">&#45;&gt;</span></span> <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-stream">Sockaddr.stream</a> list</span></span></code></div><div class="spec-doc"><p><code>getaddrinfo_stream</code> is like <a href="#val-getaddrinfo"><code>getaddrinfo</code></a>, but filters out non-stream protocols.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-getaddrinfo_datagram"><a href="#val-getaddrinfo_datagram" class="anchor"></a><code><span><span class="keyword">val</span> getaddrinfo_datagram : 
  <span>?service:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Sockaddr/index.html#type-datagram">Sockaddr.datagram</a> list</span></span></code></div><div class="spec-doc"><p><code>getaddrinfo_datagram</code> is like <a href="#val-getaddrinfo"><code>getaddrinfo</code></a>, but filters out non-datagram protocols.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-getnameinfo"><a href="#val-getnameinfo" class="anchor"></a><code><span><span class="keyword">val</span> getnameinfo : <span><a href="class-t/index.html">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-t">Sockaddr.t</a> <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>getnameinfo t sockaddr</code> is <code>(hostname, service)</code> corresponding to <code>sockaddr</code>. <code>hostname</code> is the registered domain name represented by <code>sockaddr</code>. <code>service</code> is the IANA specified textual name of the port specified in <code>sockaddr</code>, e.g. 'ftp', 'http', 'https', etc.</p></div></div><h3 id="closing"><a href="#closing" class="anchor"></a>Closing</h3><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="../Generic/class-type-close/index.html">Generic.close</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Alias of <a href="../Generic/class-type-close/index.html"><code>Generic.close</code></a>.</p></div></div></div></body></html>