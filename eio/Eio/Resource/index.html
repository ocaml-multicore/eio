<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Resource (eio.Eio.Resource)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Resource</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Resource</span></code></h1><p>Defines the base resource type.</p><p>Resources are typically operating-system provided resources such as open files and network sockets. However, they can also be pure OCaml resources (such as mocks) or wrappers (such as an encrypted flow that wraps an unencrypted OS flow).</p><p>A resource's type shows which interfaces it supports. For example, a <code>[source | sink] t</code> is a resource that can be used as a source or a sink.</p><p>If you are familiar with object types, this is roughly equivalent to the type <code>&lt;source; sink&gt;</code>. We avoid using object types here as some OCaml programmers find them confusing.</p></header><nav class="odoc-toc"><ul><li><a href="#types">Types</a></li><li><a href="#defining-new-interfaces">Defining new interfaces</a></li><li><a href="#closing">Closing</a></li></ul></nav><div class="odoc-content"><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div class="odoc-spec"><div class="spec type anchored" id="type-handler"><a href="#type-handler" class="anchor"></a><code><span><span class="keyword">type</span> <span>('t, -'tags) handler</span></span></code></div><div class="spec-doc"><p>A <code>('t, 'tags) handler</code> can be used to look up the implementation for a type <code>'t</code>.</p><p><code>'tags</code> is a phantom type to record which interfaces are supported.</p><p>Internally, a handler is a set of <a href="#type-binding"><code>binding</code></a>s.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>-'tags t</span></span><span> = </span></code><ol><li id="type-t.T" class="def variant constructor anchored"><a href="#type-t.T" class="anchor"></a><code><span>| </span><span><span class="constructor">T</span> : <span>(<span class="type-var">'t</span> * <span><span>(<span class="type-var">'t</span>, <span class="type-var">'tags</span>)</span> <a href="#type-handler">handler</a></span>)</span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'tags</span> <a href="#type-t">t</a></span></span></code></li></ol></div><div class="spec-doc"><p>A resource is a pair of a value and a handler for it.</p><p>Normally there will be convenience functions provided for using resources and you will not need to match on <code>T</code> yourself except when defining a new interface.</p></div></div><h3 id="defining-new-interfaces"><a href="#defining-new-interfaces" class="anchor"></a>Defining new interfaces</h3><p>These types and functions can be used to define new interfaces that others can implement.</p><p>When defining a new interface, you will typically provide:</p><ul><li>The tags that indicate that the interface is supported (e.g. <a href="../Flow/index.html#type-source_ty"><code>Flow.source_ty</code></a>).</li><li>A convenience type to match all sub-types easily (e.g. <a href="../Flow/index.html#type-source"><code>Flow.source</code></a>).</li><li>Functions allowing users to call the interface (e.g. <a href="../Flow/index.html#val-single_read"><code>Flow.single_read</code></a>).</li><li>A module to let providers implement the interface (e.g. <a href="../Flow/Pi/index.html"><code>Flow.Pi</code></a>).</li></ul><div class="odoc-spec"><div class="spec type anchored" id="type-pi"><a href="#type-pi" class="anchor"></a><code><span><span class="keyword">type</span> <span>('t, 'iface, 'tag) pi</span></span><span> = </span><span>..</span></code></div><div class="spec-doc"><p>A provider interface describes an interface that a resource can implement.</p><ul><li><code>'t</code> is the type of the resource itself.</li><li><code>'iface</code> is the API that can be requested.</li><li><code>'tag</code> is the tag (or tags) indicating that the interface is supported.</li></ul><p>For example, the value <a href="#extension-Close"><code>Close</code></a> (of type <code>(fd, fd -&gt; unit, [&gt; `Close]) pi</code>) can be used with a resource backed by an <code>fd</code>, and which offers at least the <code>`Close</code> tag, to request its close function. Often, the API requested will be a module type, but it can be a single function as in this example.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binding"><a href="#type-binding" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ binding</span></span><span> = </span></code><ol><li id="type-binding.H" class="def variant constructor anchored"><a href="#type-binding.H" class="anchor"></a><code><span>| </span><span><span class="constructor">H</span> : <span><span>(<span class="type-var">'t</span>, <span class="type-var">'impl</span>, <span class="type-var">'tags</span>)</span> <a href="#type-pi">pi</a></span> * <span class="type-var">'impl</span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'t</span> <a href="#type-binding">binding</a></span></span></code></li></ol></div><div class="spec-doc"><p>A binding <code>H (pi, impl)</code> says to use <code>impl</code> to implement <code>pi</code>.</p><p>For example: <code>H (Close, M.close)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-handler"><a href="#val-handler" class="anchor"></a><code><span><span class="keyword">val</span> handler : <span><span><span><span class="type-var">'t</span> <a href="#type-binding">binding</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">_</span>)</span> <a href="#type-handler">handler</a></span></span></code></div><div class="spec-doc"><p><code>handler ops</code> is a handler that looks up interfaces using the assoc list <code>ops</code>.</p><p>For example <code>shutdown (module Foo)</code> is a handler that handles the <code>Close</code> and <code>Shutdown</code> interfaces for resources of type <code>Foo.t</code> by using the <code>Foo</code> module:</p><pre class="language-ocaml"><code>let shutdown (type t) (module X : SHUTDOWN with type t = t) : (t, shutdown_ty) handler =
  handler [
    H (Close, X.close);
    H (Shutdown, (module X));
  ]</code></pre><p>Be sure to give the return type explicitly, as this cannot be inferred.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bindings"><a href="#val-bindings" class="anchor"></a><code><span><span class="keyword">val</span> bindings : <span><span><span>(<span class="type-var">'t</span>, <span class="type-var">_</span>)</span> <a href="#type-handler">handler</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="#type-binding">binding</a></span> list</span></span></code></div><div class="spec-doc"><p><code>bindings (handler ops) = ops</code>.</p><p>This is useful if you want to extend an interface and you already have a handler for that interface.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span>(<span class="type-var">'t</span>, <span class="type-var">'tags</span>)</span> <a href="#type-handler">handler</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'t</span>, <span class="type-var">'impl</span>, <span class="type-var">'tags</span>)</span> <a href="#type-pi">pi</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'impl</span></span></code></div><div class="spec-doc"><p><code>get handler iface</code> uses <code>handler</code> to get the implementation of <code>iface</code>.</p><p>For example:</p><pre class="language-ocaml"><code>let write (Resource.T (t, ops)) bufs =
  let module X = (val (Resource.get ops Sink)) in
  X.write t bufs</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_opt"><a href="#val-get_opt" class="anchor"></a><code><span><span class="keyword">val</span> get_opt : <span><span><span>(<span class="type-var">'t</span>, <span class="type-var">_</span>)</span> <a href="#type-handler">handler</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'t</span>, <span class="type-var">'impl</span>, <span class="type-var">_</span>)</span> <a href="#type-pi">pi</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'impl</span> option</span></span></code></div><div class="spec-doc"><p><code>get_opt</code> is like <a href="#val-get"><code>get</code></a>, but the handler need not have a compatible type. Instead, this performs a check at runtime and returns <code>None</code> if the interface is not supported.</p></div></div><h3 id="closing"><a href="#closing" class="anchor"></a>Closing</h3><p>Resources are usually attached to switches and closed automatically when the switch finishes. However, it can be useful to close them sooner in some cases.</p><div class="odoc-spec"><div class="spec type anchored" id="type-close_ty"><a href="#type-close_ty" class="anchor"></a><code><span><span class="keyword">type</span> close_ty</span><span> = </span><span>[ </span></code><ol><li id="type-close_ty.Close" class="def variant constructor anchored"><a href="#type-close_ty.Close" class="anchor"></a><code><span>| </span><span>`Close</span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Close"><a href="#extension-decl-Close" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-pi">pi</a> += </span></code><ol><li id="extension-Close" class="def variant extension anchored"><a href="#extension-Close" class="anchor"></a><code><span>| </span><span><span class="extension">Close</span> : <span><span>(<span class="type-var">'t</span>, <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> unit, <span>[&gt; <a href="#type-close_ty">close_ty</a> ]</span>)</span> <a href="#type-pi">pi</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><span><span>[&gt; <a href="#type-close_ty">close_ty</a> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close t</code> marks the resource as closed. It can no longer be used after this.</p><p>If <code>t</code> is already closed then this does nothing (it does not raise an exception).</p><p>Note: if an operation is currently in progress when this is called then it is not necessarily cancelled, and any underlying OS resource (such as a file descriptor) might not be closed immediately if other operations are using it. Closing a resource only prevents new operations from starting.</p></div></div></div></body></html>
