<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Buf_read (eio.Eio.Buf_read)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Buf_read</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Buf_read</span></code></h1><p>Buffered input and parsing</p><p>This module provides fairly efficient non-backtracking parsers. It is modelled on Angstrom's API, and you should use that if backtracking is needed.</p><p>Example:</p><pre><code>let r = Buf_read.of_flow flow ~max_size:1_000_000 in
Buf_read.line r</code></pre></header><nav class="odoc-toc"><ul><li><a href="#reading-data">Reading data</a></li><li><a href="#combinators">Combinators</a></li><li><a href="#low-level-api">Low-level API</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>An input buffer.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Buffer_limit_exceeded" class="anchored"><a href="#exception-Buffer_limit_exceeded" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Buffer_limit_exceeded</span></span></code></div><div class="spec-doc"><p>Raised if parsing an item would require enlarging the buffer beyond its configured limit.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-parser" class="anchored"><a href="#type-parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a parser</span></span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>An <code>'a parser</code> is a function that consumes and returns a value of type <code>'a</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>The flow can't be parsed as a value of type <code>'a</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>The flow ended without enough data to parse an <code>'a</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Buffer_limit_exceeded</span> <p>Parsing the value would exceed the configured size limit.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-parse" class="anchored"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span>?initial_size:int <span class="arrow">&#45;&gt;</span></span> <span>max_size:int <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Flow</span>.#source <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>parse p flow ~max_size</code> uses <code>p</code> to parse everything in <code>flow</code>.</p><p>It is a convenience function that does</p><pre><code>let buf = of_flow flow ~max_size in
format_errors (p &lt;* eof) buf</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">initial_size</span> <p>see <code>of_flow</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-parse_exn" class="anchored"><a href="#val-parse_exn" class="anchor"></a><code><span><span class="keyword">val</span> parse_exn : <span>?initial_size:int <span class="arrow">&#45;&gt;</span></span> <span>max_size:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Flow</span>.#source <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>parse_exn</code> wraps <a href="#val-parse"><code>parse</code></a>, but raises <code>Failure msg</code> if that returns <code>Error (`Msg msg)</code>.</p><p>Catching exceptions with <code>parse</code> and then raising them might seem pointless, but this has the effect of turning e.g. an <code>End_of_file</code> exception into a <code>Failure</code> with a more user-friendly message.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_flow" class="anchored"><a href="#val-of_flow" class="anchor"></a><code><span><span class="keyword">val</span> of_flow : <span>?initial_size:int <span class="arrow">&#45;&gt;</span></span> <span>max_size:int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Flow</span>.#source <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_flow ~max_size flow</code> is a buffered reader backed by <code>flow</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">initial_size</span> <p>The initial amount of memory to allocate for the buffer.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_size</span> <p>The maximum size to which the buffer may grow. This must be large enough to hold the largest single item you want to parse (e.g. the longest line, if using <code>line</code>), plus any terminator needed to know the value is complete (e.g. the newline character(s)). This is just to prevent a run-away input from consuming all memory, and you can usually just set it much larger than you expect to need.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-as_flow" class="anchored"><a href="#val-as_flow" class="anchor"></a><code><span><span class="keyword">val</span> as_flow : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Flow/class-source/index.html">Flow.source</a></span></code></div><div class="spec-doc"><p><code>as_flow t</code> is a buffered flow.</p><p>Reading from it will return data from the buffer, only reading the underlying flow if the buffer is empty.</p></div></div><h3 id="reading-data"><a href="#reading-data" class="anchor"></a>Reading data</h3><div class="odoc-spec"><div class="spec value" id="val-line" class="anchored"><a href="#val-line" class="anchor"></a><code><span><span class="keyword">val</span> line : <span>string <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>line</code> parses one line.</p><p>Lines can be terminated by either LF or CRLF. The returned string does not include the terminator.</p><p>If <code>End_of_file</code> is reached after seeing some data but before seeing a line terminator, the data seen is returned as the last line.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lines" class="anchored"><a href="#val-lines" class="anchor"></a><code><span><span class="keyword">val</span> lines : <span><span>string <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>lines</code> returns a sequence that lazily reads the next line until the end of the input is reached.</p><p><code>lines = seq line ~stop:at_end_of_input</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>char c</code> checks that the next byte is <code>c</code> and consumes it.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if the next byte is not <code>c</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-any_char" class="anchored"><a href="#val-any_char" class="anchor"></a><code><span><span class="keyword">val</span> any_char : <span>char <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>any_char</code> parses one character.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_char" class="anchored"><a href="#val-peek_char" class="anchor"></a><code><span><span class="keyword">val</span> peek_char : <span><span>char option</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>peek_char</code> returns <code>Some c</code> where <code>c</code> is the next character, but does not consume it.</p><p>Returns <code>None</code> at the end of the input stream rather than raising <code>End_of_file</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>string s</code> checks that <code>s</code> is the next string in the stream and consumes it.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if <code>s</code> is not a prefix of the stream.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>take n</code> takes exactly <code>n</code> bytes from the input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_all" class="anchored"><a href="#val-take_all" class="anchor"></a><code><span><span class="keyword">val</span> take_all : <span>string <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>take_all</code> takes all remaining data until end-of-file.</p><p>Returns <code>&quot;&quot;</code> if already at end-of-file.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Buffer_limit_exceeded</span> <p>if the remaining data exceeds or equals the buffer limit (it needs one extra byte to confirm it has reached end-of-file).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>take_while p</code> finds the first byte for which <code>p</code> is false and consumes and returns all bytes before that.</p><p>If <code>p</code> is true for all remaining bytes, it returns everything until end-of-file.</p><p>It will return the empty string if there are no matching characters (and therefore never raises <code>End_of_file</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skip_while" class="anchored"><a href="#val-skip_while" class="anchor"></a><code><span><span class="keyword">val</span> skip_while : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>skip_while p</code> skips zero or more bytes for which <code>p</code> is <code>true</code>.</p><p><code>skip_while p t</code> does the same thing as <code>ignore (take_while p t)</code>, except that it is not limited by the buffer size.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skip" class="anchored"><a href="#val-skip" class="anchor"></a><code><span><span class="keyword">val</span> skip : <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>skip n</code> discards the next <code>n</code> bytes.</p><p><code>skip n</code> = <code>map ignore (take n)</code>, except that the number of skipped bytes may be larger than the buffer (it will not grow).</p><p>Note: if <code>End_of_file</code> is raised, all bytes in the stream will have been consumed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-at_end_of_input" class="anchored"><a href="#val-at_end_of_input" class="anchor"></a><code><span><span class="keyword">val</span> at_end_of_input : <span>bool <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>at_end_of_input</code> returns <code>true</code> when at the end of the stream, or <code>false</code> if there is at least one more byte to be read.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-end_of_input" class="anchored"><a href="#val-end_of_input" class="anchor"></a><code><span><span class="keyword">val</span> end_of_input : <span>unit <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>end_of_input</code> checks that there are no further bytes in the stream.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if there are further bytes</p></li></ul></div></div><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3><div class="odoc-spec"><div class="spec value" id="val-seq" class="anchored"><a href="#val-seq" class="anchor"></a><code><span><span class="keyword">val</span> seq : <span>?stop:<span>bool <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>seq p</code> is a sequence that uses <code>p</code> to get the next item.</p><p>A sequence node can only be used while the stream is at the expected position, and will raise <code>Invalid_argument</code> if any bytes have been consumed in the meantime. This also means that each node can only be used once; use <code>Seq</code>.memoize to make the sequence persistent.</p><p>It is not necessary to consume all the elements of the sequence.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stop</span> <p>This is used before parsing each item. The sequence ends if this returns <code>true</code>. The default is <code>at_end_of_input</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pair" class="anchored"><a href="#val-pair" class="anchor"></a><code><span><span class="keyword">val</span> pair : <span><span><span class="type-var">'a</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>pair a b</code> is a parser that first uses <code>a</code> to parse a value <code>x</code>, then uses <code>b</code> to parse a value <code>y</code>, then returns <code>(x, y)</code>.</p><p>Note that this module does not support backtracking, so if <code>b</code> fails then the bytes consumed by <code>a</code> are lost.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>map f a</code> is a parser that parses the stream with <code>a</code> to get <code>v</code>, and then returns <code>f v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-parser">parser</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>bind a f</code> is a parser that first uses <code>a</code> to parse a value <code>v</code>, then uses <code>f v</code> to select the next parser, and then uses that.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-format_errors" class="anchored"><a href="#val-format_errors" class="anchor"></a><code><span><span class="keyword">val</span> format_errors : <span><span><span class="type-var">'a</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p><code>format_errors p</code> catches <code>Failure</code>, <code>End_of_file</code> and <code>Buffer_limit_exceeded</code> exceptions and returns them as a formatted error message.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Syntax" class="anchored"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Syntax/index.html">Syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Convenient syntax for some of the combinators.</p></div></div><h3 id="low-level-api"><a href="#low-level-api" class="anchor"></a>Low-level API</h3><div class="odoc-spec"><div class="spec value" id="val-buffered_bytes" class="anchored"><a href="#val-buffered_bytes" class="anchor"></a><code><span><span class="keyword">val</span> buffered_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>buffered_bytes t</code> is the number of bytes that can be read without reading from the underlying flow.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Cstruct</span>.t</span></code></div><div class="spec-doc"><p><code>peek t</code> returns a view onto the active part of <code>t</code>'s internal buffer.</p><p>Performing any operation that might add to the buffer may invalidate this, so it should be used immediately and then forgotten.</p><p><code>Cstruct.length (peek t) = buffered_bytes t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ensure" class="anchored"><a href="#val-ensure" class="anchor"></a><code><span><span class="keyword">val</span> ensure : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>ensure t n</code> ensures that the buffer contains at least <code>n</code> bytes of data.</p><p>If not, it reads from the flow until there is.</p><p><code>buffered_bytes (ensure t n) &gt;= n</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>if the flow ended before <code>n</code> bytes were available</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Buffer_limit_exceeded</span> <p>if <code>n</code> exceeds the buffer's maximum size</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-consume" class="anchored"><a href="#val-consume" class="anchor"></a><code><span><span class="keyword">val</span> consume : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>consume t n</code> discards the first <code>n</code> bytes from <code>t</code>'s buffer.</p><p>Use this after <a href="#val-peek"><code>peek</code></a> to mark some bytes as consumed.</p><p><code>buffered_bytes t' = buffered_bytes t - n</code></p><p>Note: unlike <a href="#val-skip"><code>skip</code></a>, this will not read data from the underlying flow.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-consumed_bytes" class="anchored"><a href="#val-consumed_bytes" class="anchor"></a><code><span><span class="keyword">val</span> consumed_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>consumed_bytes t</code> is the total number of bytes consumed.</p><p>i.e. it is the offset into the stream of the next byte to be parsed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eof_seen" class="anchored"><a href="#val-eof_seen" class="anchor"></a><code><span><span class="keyword">val</span> eof_seen : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>eof_seen t</code> indicates whether we've received <code>End_of_file</code> from the underlying flow.</p><p>If so, there will never be any further data beyond what <code>peek</code> already returns.</p><p>Note that this returns <code>false</code> if we're at the end of the stream but don't know it yet. Use <a href="#val-at_end_of_input"><code>at_end_of_input</code></a> to be sure.</p></div></div></div></body></html>