<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Condition (eio.Eio.Condition)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Condition</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Condition</span></code></h1><p>Waiting for a condition to become true.</p><p>Waiters call <a href="#val-await"><code>await</code></a> in a loop as long as some condition is false. Fibers that modify inputs to the condition must call <code>broadcast</code> soon afterwards so that waiters can re-check the condition.</p><p>Example:</p><pre class="language-ocaml"><code>let x = ref 0
let cond = Eio.Condition.create ()
let mutex = Eio.Mutex.create ()

let set_x value =
  Eio.Mutex.use_rw ~protect:false mutex (fun () -&gt; x := value);
  Eio.Condition.broadcast cond

let await_x p =
  Eio.Mutex.use_ro mutex (fun () -&gt;
     while not (p !x) do                  (* [x] cannot change, as mutex is locked. *)
       Eio.Condition.await cond mutex     (* Mutex is unlocked while suspended. *)
     done
  )</code></pre><p>It is used like this:</p><pre class="language-ocaml"><code>Fiber.both
  (fun () -&gt;
     traceln &quot;x = %d&quot; !x;
     await_x ((=) 42);
     traceln &quot;x = %d&quot; !x
  )
  (fun () -&gt;
     set_x 5;
     Fiber.yield ();
     set_x 7;
     set_x 42;
  )</code></pre></header><nav class="odoc-toc"><ul><li><a href="#low-level-api">Low-level API</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ()</code> creates a new condition variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Eio__/Eio_mutex/index.html#type-t">Mutex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>await t mutex</code> suspends the current fiber until it is notified by <code>t</code>.</p><p>You should lock <code>mutex</code> before testing whether the condition is true, and leave it locked while calling this function. It will be unlocked while the fiber is waiting and locked again before returning (it is also locked again if the wait is cancelled).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_no_mutex"><a href="#val-await_no_mutex" class="anchor"></a><code><span><span class="keyword">val</span> await_no_mutex : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>await_no_mutex t</code> suspends the current fiber until it is notified by <code>t</code>.</p><p>This is only safe to use in the case where <code>t</code> is only used within a single domain, and the test for the condition was done without switching fibers. i.e. you know the condition is still false, and no notification of a change can be sent until <code>await_no_mutex</code> has finished suspending the fiber.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-loop_no_mutex"><a href="#val-loop_no_mutex" class="anchor"></a><code><span><span class="keyword">val</span> loop_no_mutex : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>loop_no_mutex t update</code> runs <code>update ()</code> until it returns <code>Some x</code>, then returns <code>x</code>.</p><p>If <code>update ()</code> returns <code>None</code> then it waits until <a href="#val-broadcast"><code>broadcast</code></a> is called before retrying. If <a href="#val-broadcast"><code>broadcast</code></a> is called while <code>update</code> is running, <code>update</code> runs again immediately.</p><p>For example, if <code>broadcast config_changed</code> is performed after some configuration file is changed, then you can ensure <code>load_config</code> will always eventually have seen the latest configuration like this:</p><pre class="language-ocaml"><code>Fiber.fork_daemon ~sw (fun () -&gt;
  loop_no_mutex config_changed (fun () -&gt; load_config (); None)
)</code></pre><p>Note that, since there is no lock, <code>load_config</code> may see a half-written update if the configuration is changed again before it finishes reading it, so it should just log the error and wait to be called again.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-broadcast"><a href="#val-broadcast" class="anchor"></a><code><span><span class="keyword">val</span> broadcast : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>broadcast t</code> wakes up any waiting fibers (by appending them to the run-queue to resume later).</p><p>If no fibers are waiting, nothing happens.</p></div></div><h3 id="low-level-api"><a href="#low-level-api" class="anchor"></a>Low-level API</h3><p>This is intended only for integrating Eio with other IO libraries.</p><div class="odoc-spec"><div class="spec type anchored" id="type-request"><a href="#type-request" class="anchor"></a><code><span><span class="keyword">type</span> request</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-register_immediate"><a href="#val-register_immediate" class="anchor"></a><code><span><span class="keyword">val</span> register_immediate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-request">request</a></span></code></div><div class="spec-doc"><p><code>register_immediate t fn</code> will call <code>fn ()</code> the next time <a href="#val-broadcast"><code>broadcast</code></a> is called.</p><p><code>fn</code> runs immediately from the caller's context, which might not be an Eio thread, or may be a signal handler, etc. Therefore, care is needed here. This is typically used to send a wake-up event to some non-Eio library.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span><span class="keyword">val</span> cancel : <span><a href="#type-request">request</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>cancel request</code> tries to cancel a request created with <code>register_unsafe</code>.</p><p>It returns <code>true</code> if the request was cancelled (the callback will never be called), or <code>false</code> if the request was already complete (the callback has already been called).</p></div></div></div></body></html>
