<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Low_level (eio_linux.Eio_linux.Low_level)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.0.0-823-ge94c197"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio_linux</a> &#x00BB; <a href="../index.html">Eio_linux</a> &#x00BB; Low_level</nav><header class="odoc-preamble"><h1>Module <code><span>Eio_linux.Low_level</span></code></h1><p>Low-level API for using uring directly.</p></header><nav class="odoc-toc"><ul><li><a href="#time-functions">Time functions</a></li><li><a href="#fixed-buffer-memory-allocation-functions">Fixed-buffer memory allocation functions</a></li><li><a href="#file-manipulation-functions">File manipulation functions</a></li><li><a href="#sockets">Sockets</a></li><li><a href="#randomness">Randomness</a></li><li><a href="#dns-functions">DNS functions</a></li><li><a href="#processes">Processes</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-noop"><a href="#val-noop" class="anchor"></a><code><span><span class="keyword">val</span> noop : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>noop ()</code> performs a uring noop. This is only useful for benchmarking.</p></div></div><h2 id="time-functions"><a href="#time-functions" class="anchor"></a>Time functions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-sleep_until"><a href="#val-sleep_until" class="anchor"></a><code><span><span class="keyword">val</span> sleep_until : <span><span class="xref-unresolved">Mtime</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>sleep_until time</code> blocks until the current time is <code>time</code>.</p></div></div><h2 id="fixed-buffer-memory-allocation-functions"><a href="#fixed-buffer-memory-allocation-functions" class="anchor"></a>Fixed-buffer memory allocation functions</h2><p>The size of the fixed buffer is set when calling <a href="../index.html#val-run"><code>run</code></a>, which attempts to allocate a fixed buffer. However, that may fail due to resource limits.</p><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_fixed"><a href="#val-alloc_fixed" class="anchor"></a><code><span><span class="keyword">val</span> alloc_fixed : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Uring</span>.Region.chunk option</span></span></code></div><div class="spec-doc"><p>Allocate a chunk of memory from the fixed buffer.</p><p>Warning: The memory is NOT zeroed out.</p><p>Passing such memory to Linux can be faster than using normal memory, in certain cases. There is a limited amount of such memory, and this will return <code>None</code> if none is available at present.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_fixed_or_wait"><a href="#val-alloc_fixed_or_wait" class="anchor"></a><code><span><span class="keyword">val</span> alloc_fixed_or_wait : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Uring</span>.Region.chunk</span></code></div><div class="spec-doc"><p>Like <a href="#val-alloc_fixed"><code>alloc_fixed</code></a>, but if there are no chunks available then it waits until one is.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-free_fixed"><a href="#val-free_fixed" class="anchor"></a><code><span><span class="keyword">val</span> free_fixed : <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_chunk"><a href="#val-with_chunk" class="anchor"></a><code><span><span class="keyword">val</span> with_chunk : <span><span class="label">fallback</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_chunk ~fallback fn</code> runs <code>fn chunk</code> with a freshly allocated chunk and then frees it.</p><p>If no chunks are available, it runs <code>fallback ()</code> instead.</p></div></div><h2 id="file-manipulation-functions"><a href="#file-manipulation-functions" class="anchor"></a>File manipulation functions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-openat2"><a href="#val-openat2" class="anchor"></a><code><span><span class="keyword">val</span> openat2 : 
  <span><span class="label">sw</span>:<a href="../../../eio/Eio/Switch/index.html#type-t">Eio.Std.Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?seekable</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">access</span>:<span>[ `R <span>| `W</span> <span>| `RW</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">flags</span>:<span class="xref-unresolved">Uring</span>.Open_flags.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">perm</span>:<span class="xref-unresolved">Unix</span>.file_perm <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">resolve</span>:<span class="xref-unresolved">Uring</span>.Resolve.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?dir</span>:<a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="../index.html#type-fd">fd</a></span></code></div><div class="spec-doc"><p><code>openat2 ~sw ~flags ~perm ~resolve ~dir path</code> opens <code>dir/path</code>.</p><p>See <code>Uring.openat2</code> for details.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_upto"><a href="#val-read_upto" class="anchor"></a><code><span><span class="keyword">val</span> read_upto : 
  <span><span class="optlabel">?file_offset</span>:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div><div class="spec-doc"><p><code>read_upto fd chunk len</code> reads at most <code>len</code> bytes from <code>fd</code>, returning as soon as some data is available.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">file_offset</span> <p>Read from the given position in <code>fd</code> (default: 0).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>End_of_file</code> <p>Raised if all data has already been read.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_exactly"><a href="#val-read_exactly" class="anchor"></a><code><span><span class="keyword">val</span> read_exactly : 
  <span><span class="optlabel">?file_offset</span>:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>read_exactly fd chunk len</code> reads exactly <code>len</code> bytes from <code>fd</code>, performing multiple read operations if necessary.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">file_offset</span> <p>Read from the given position in <code>fd</code> (default: 0).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>End_of_file</code> <p>Raised if the stream ends before <code>len</code> bytes have been read.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-readv"><a href="#val-readv" class="anchor"></a><code><span><span class="keyword">val</span> readv : <span><span class="optlabel">?file_offset</span>:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>readv</code> is like <a href="#val-read_upto"><code>read_upto</code></a> but can read into any cstruct(s), not just chunks of the pre-shared buffer.</p><p>If multiple buffers are given, they are filled in order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : 
  <span><span class="optlabel">?file_offset</span>:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>write fd buf len</code> writes exactly <code>len</code> bytes from <code>buf</code> to <code>fd</code>.</p><p>It blocks until the OS confirms the write is done, and resubmits automatically if the OS doesn't write all of it at once.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-writev"><a href="#val-writev" class="anchor"></a><code><span><span class="keyword">val</span> writev : <span><span class="optlabel">?file_offset</span>:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>writev</code> is like <a href="#val-write"><code>write</code></a> but can write from any cstruct(s), not just chunks of the pre-shared buffer.</p><p>If multiple buffers are given, they are sent in order. It will make multiple OS calls if the OS doesn't write all of it at once.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-writev_single"><a href="#val-writev_single" class="anchor"></a><code><span><span class="keyword">val</span> writev_single : <span><span class="optlabel">?file_offset</span>:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>writev_single</code> is like <code>writev</code> but only performs a single write operation. It returns the number of bytes written, which may be smaller than the requested amount.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-splice"><a href="#val-splice" class="anchor"></a><code><span><span class="keyword">val</span> splice : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst</span>:<a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>splice src ~dst ~len</code> attempts to copy up to <code>len</code> bytes of data from <code>src</code> to <code>dst</code>.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The number of bytes copied.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>End_of_file</code> <p><code>src</code> is at the end of the file.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Unix.Unix_error(EINVAL,</code> <p>&quot;splice&quot;, _) if splice is not supported for these FDs.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Unix</span>.sockaddr <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>connect fd addr</code> attempts to connect socket <code>fd</code> to <code>addr</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_readable"><a href="#val-await_readable" class="anchor"></a><code><span><span class="keyword">val</span> await_readable : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>await_readable fd</code> blocks until <code>fd</code> is readable (or has an error).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_writable"><a href="#val-await_writable" class="anchor"></a><code><span><span class="keyword">val</span> await_writable : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>await_writable fd</code> blocks until <code>fd</code> is writable (or has an error).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fstat"><a href="#val-fstat" class="anchor"></a><code><span><span class="keyword">val</span> fstat : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../eio/Eio/File/Stat/index.html#type-t">Eio.File.Stat.t</a></span></code></div><div class="spec-doc"><p>Like <code>Unix.LargeFile.fstat</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-statx"><a href="#val-statx" class="anchor"></a><code><span><span class="keyword">val</span> statx : 
  <span><span class="optlabel">?fd</span>:<a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">mask</span>:<span class="xref-unresolved">Uring</span>.Statx.Mask.t <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Statx.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Statx.Flags.t <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>statx t ?fd ~mask path buf flags</code> stats <code>path</code>, which is resolved relative to <code>fd</code> (or the current directory if <code>fd</code> is not given).</p><p>The results are written to <code>buf</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_dir"><a href="#val-read_dir" class="anchor"></a><code><span><span class="keyword">val</span> read_dir : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>read_dir dir</code> reads all directory entries from <code>dir</code>. The entries are not returned in any particular order (not even necessarily the order in which Linux returns them).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lseek"><a href="#val-lseek" class="anchor"></a><code><span><span class="keyword">val</span> lseek : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Set <span>| `Cur</span> <span>| `End</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Optint</span>.Int63.t</span></code></div><div class="spec-doc"><p>Set and/or get the current file position.</p><p>Like <code>Unix.lseek</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fsync"><a href="#val-fsync" class="anchor"></a><code><span><span class="keyword">val</span> fsync : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Flush file buffers to disk.</p><p>Like <code>Unix.fsync</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ftruncate"><a href="#val-ftruncate" class="anchor"></a><code><span><span class="keyword">val</span> ftruncate : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Set the length of a file.</p><p>Like <code>Unix.ftruncate</code>.</p></div></div><h2 id="sockets"><a href="#sockets" class="anchor"></a>Sockets</h2><div class="odoc-spec"><div class="spec value anchored" id="val-accept"><a href="#val-accept" class="anchor"></a><code><span><span class="keyword">val</span> accept : <span><span class="label">sw</span>:<a href="../../../eio/Eio/Switch/index.html#type-t">Eio.Std.Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-fd">fd</a> * <span class="xref-unresolved">Unix</span>.sockaddr</span></code></div><div class="spec-doc"><p><code>accept ~sw t</code> blocks until a new connection is received on listening socket <code>t</code>.</p><p>It returns the new connection and the address of the connecting peer. The new connection has the close-on-exec flag set automatically. The new connection is attached to <code>sw</code> and will be closed when that finishes, if not already closed manually by then.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span><span class="keyword">val</span> shutdown : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Unix</span>.shutdown_command <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Like <code>Unix.shutdown</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-send_msg"><a href="#val-send_msg" class="anchor"></a><code><span><span class="keyword">val</span> send_msg : 
  <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?fds</span>:<span><a href="../index.html#type-fd">fd</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?dst</span>:<span class="xref-unresolved">Unix</span>.sockaddr <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div><div class="spec-doc"><p><code>send_msg socket bufs</code> is like <code>writev socket bufs</code>, but also allows setting the destination address (for unconnected sockets) and attaching FDs (for Unix-domain sockets).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-recv_msg"><a href="#val-recv_msg" class="anchor"></a><code><span><span class="keyword">val</span> recv_msg : <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Uring</span>.Sockaddr.t * int</span></code></div><div class="spec-doc"><p><code>recv_msg socket bufs</code> is like <code>readv socket bufs</code> but also returns the address of the sender.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-recv_msg_with_fds"><a href="#val-recv_msg_with_fds" class="anchor"></a><code><span><span class="keyword">val</span> recv_msg_with_fds : 
  <span><span class="label">sw</span>:<a href="../../../eio/Eio/Switch/index.html#type-t">Eio.Std.Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_fds</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-fd">fd</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Uring</span>.Sockaddr.t * int * <span><a href="../index.html#type-fd">fd</a> list</span></span></code></div><div class="spec-doc"><p><code>recv_msg_with_fds</code> is like <code>recv_msg</code> but also allows receiving up to <code>max_fds</code> file descriptors (sent using SCM_RIGHTS over a Unix domain socket).</p></div></div><h2 id="randomness"><a href="#randomness" class="anchor"></a>Randomness</h2><div class="odoc-spec"><div class="spec value anchored" id="val-getrandom"><a href="#val-getrandom" class="anchor"></a><code><span><span class="keyword">val</span> getrandom : <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>getrandom buf</code> fills <code>buf</code> with random bytes.</p><p>It uses Linux's <code>getrandom</code> call, which is like reading from /dev/urandom except that it will block (the whole domain) if used at early boot when the random system hasn't been initialised yet.</p></div></div><h2 id="dns-functions"><a href="#dns-functions" class="anchor"></a>DNS functions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-getaddrinfo"><a href="#val-getaddrinfo" class="anchor"></a><code><span><span class="keyword">val</span> getaddrinfo : <span><span class="label">service</span>:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../eio/Eio/Net/Sockaddr/index.html#type-t">Eio.Net.Sockaddr.t</a> list</span></span></code></div><div class="spec-doc"><p><code>getaddrinfo host</code> returns a list of IP addresses for <code>host</code>. <code>host</code> is either a domain name or an ipaddress.</p></div></div><h2 id="processes"><a href="#processes" class="anchor"></a>Processes</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Process"><a href="#module-Process" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Process/index.html">Process</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
