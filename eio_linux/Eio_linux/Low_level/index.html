<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Low_level (eio_linux.Eio_linux.Low_level)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio_linux</a> &#x00BB; <a href="../index.html">Eio_linux</a> &#x00BB; Low_level</nav><header class="odoc-preamble"><h1>Module <code><span>Eio_linux.Low_level</span></code></h1><p>Low-level API for using uring directly.</p></header><nav class="odoc-toc"><ul><li><a href="#time-functions">Time functions</a></li><li><a href="#fixed-buffer-memory-allocation-functions">Fixed-buffer memory allocation functions</a></li><li><a href="#file-manipulation-functions">File manipulation functions</a></li><li><a href="#sockets">Sockets</a></li><li><a href="#randomness">Randomness</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-noop" class="anchored"><a href="#val-noop" class="anchor"></a><code><span><span class="keyword">val</span> noop : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>noop ()</code> performs a uring noop. This is only useful for benchmarking.</p></div></div><h2 id="time-functions"><a href="#time-functions" class="anchor"></a>Time functions</h2><div class="odoc-spec"><div class="spec value" id="val-sleep_until" class="anchored"><a href="#val-sleep_until" class="anchor"></a><code><span><span class="keyword">val</span> sleep_until : <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>sleep_until time</code> blocks until the current time is <code>time</code>.</p></div></div><h2 id="fixed-buffer-memory-allocation-functions"><a href="#fixed-buffer-memory-allocation-functions" class="anchor"></a>Fixed-buffer memory allocation functions</h2><p>The size of the fixed buffer is set when calling <a href="../index.html#val-run"><code>run</code></a>, which attempts to allocate a fixed buffer. However, that may fail due to resource limits.</p><div class="odoc-spec"><div class="spec value" id="val-alloc_fixed" class="anchored"><a href="#val-alloc_fixed" class="anchor"></a><code><span><span class="keyword">val</span> alloc_fixed : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Uring</span>.Region.chunk option</span></span></code></div><div class="spec-doc"><p>Allocate a chunk of memory from the fixed buffer.</p><p>Warning: The memory is NOT zeroed out.</p><p>Passing such memory to Linux can be faster than using normal memory, in certain cases. There is a limited amount of such memory, and this will return <code>None</code> if none is available at present.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-alloc_fixed_or_wait" class="anchored"><a href="#val-alloc_fixed_or_wait" class="anchor"></a><code><span><span class="keyword">val</span> alloc_fixed_or_wait : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Uring</span>.Region.chunk</span></code></div><div class="spec-doc"><p>Like <a href="#val-alloc_fixed"><code>alloc_fixed</code></a>, but if there are no chunks available then it waits until one is.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-free_fixed" class="anchored"><a href="#val-free_fixed" class="anchor"></a><code><span><span class="keyword">val</span> free_fixed : <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-with_chunk" class="anchored"><a href="#val-with_chunk" class="anchor"></a><code><span><span class="keyword">val</span> with_chunk : <span>fallback:<span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_chunk ~fallback fn</code> runs <code>fn chunk</code> with a freshly allocated chunk and then frees it.</p><p>If no chunks are available, it runs <code>fallback ()</code> instead.</p></div></div><h2 id="file-manipulation-functions"><a href="#file-manipulation-functions" class="anchor"></a>File manipulation functions</h2><div class="odoc-spec"><div class="spec value" id="val-openfile" class="anchored"><a href="#val-openfile" class="anchor"></a><code><span><span class="keyword">val</span> openfile : 
  <span>sw:<a href="../../../eio/Eio/Switch/index.html#type-t">Eio.Std.Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Unix</span>.open_flag list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <a href="../FD/index.html#type-t">FD.t</a></span></code></div><div class="spec-doc"><p>Like <code>Unix</code>.open_file.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-openat2" class="anchored"><a href="#val-openat2" class="anchor"></a><code><span><span class="keyword">val</span> openat2 : 
  <span>sw:<a href="../../../eio/Eio/Switch/index.html#type-t">Eio.Std.Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?seekable:bool <span class="arrow">&#45;&gt;</span></span>
  <span>access:<span>[ `R <span>| `W</span> <span>| `RW</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>flags:<span class="xref-unresolved">Uring</span>.Open_flags.t <span class="arrow">&#45;&gt;</span></span>
  <span>perm:<span class="xref-unresolved">Unix</span>.file_perm <span class="arrow">&#45;&gt;</span></span>
  <span>resolve:<span class="xref-unresolved">Uring</span>.Resolve.t <span class="arrow">&#45;&gt;</span></span>
  <span>?dir:<a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="../FD/index.html#type-t">FD.t</a></span></code></div><div class="spec-doc"><p><code>openat2 ~sw ~flags ~perm ~resolve ~dir path</code> opens <code>dir/path</code>.</p><p>See <code>Uring</code>.openat2 for details.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_upto" class="anchored"><a href="#val-read_upto" class="anchor"></a><code><span><span class="keyword">val</span> read_upto : 
  <span>?file_offset:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div><div class="spec-doc"><p><code>read_upto fd chunk len</code> reads at most <code>len</code> bytes from <code>fd</code>, returning as soon as some data is available.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">file_offset</span> <p>Read from the given position in <code>fd</code> (default: 0).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>Raised if all data has already been read.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-read_exactly" class="anchored"><a href="#val-read_exactly" class="anchor"></a><code><span><span class="keyword">val</span> read_exactly : 
  <span>?file_offset:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>read_exactly fd chunk len</code> reads exactly <code>len</code> bytes from <code>fd</code>, performing multiple read operations if necessary.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">file_offset</span> <p>Read from the given position in <code>fd</code> (default: 0).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>Raised if the stream ends before <code>len</code> bytes have been read.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-readv" class="anchored"><a href="#val-readv" class="anchor"></a><code><span><span class="keyword">val</span> readv : <span>?file_offset:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>readv</code> is like <a href="#val-read_upto"><code>read_upto</code></a> but can read into any cstruct(s), not just chunks of the pre-shared buffer.</p><p>If multiple buffers are given, they are filled in order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write" class="anchored"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : 
  <span>?file_offset:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Uring</span>.Region.chunk <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>write fd buf len</code> writes exactly <code>len</code> bytes from <code>buf</code> to <code>fd</code>.</p><p>It blocks until the OS confirms the write is done, and resubmits automatically if the OS doesn't write all of it at once.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-writev" class="anchored"><a href="#val-writev" class="anchor"></a><code><span><span class="keyword">val</span> writev : <span>?file_offset:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>writev</code> is like <a href="#val-write"><code>write</code></a> but can write from any cstruct(s), not just chunks of the pre-shared buffer.</p><p>If multiple buffers are given, they are sent in order. It will make multiple OS calls if the OS doesn't write all of it at once.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-splice" class="anchored"><a href="#val-splice" class="anchor"></a><code><span><span class="keyword">val</span> splice : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst:<a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>splice src ~dst ~len</code> attempts to copy up to <code>len</code> bytes of data from <code>src</code> to <code>dst</code>.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The number of bytes copied.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p><code>src</code> is at the end of the file.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Unix.Unix_error(EINVAL,</span> <p>&quot;splice&quot;, _) if splice is not supported for these FDs.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-connect" class="anchored"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Unix</span>.sockaddr <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>connect fd addr</code> attempts to connect socket <code>fd</code> to <code>addr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-await_readable" class="anchored"><a href="#val-await_readable" class="anchor"></a><code><span><span class="keyword">val</span> await_readable : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>await_readable fd</code> blocks until <code>fd</code> is readable (or has an error).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-await_writable" class="anchored"><a href="#val-await_writable" class="anchor"></a><code><span><span class="keyword">val</span> await_writable : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>await_writable fd</code> blocks until <code>fd</code> is writable (or has an error).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fstat" class="anchored"><a href="#val-fstat" class="anchor"></a><code><span><span class="keyword">val</span> fstat : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Unix</span>.stats</span></code></div><div class="spec-doc"><p>Like <code>Unix</code>.fstat.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_dir" class="anchored"><a href="#val-read_dir" class="anchor"></a><code><span><span class="keyword">val</span> read_dir : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>read_dir dir</code> reads all directory entries from <code>dir</code>. The entries are not returned in any particular order (not even necessarily the order in which Linux returns them).</p></div></div><h2 id="sockets"><a href="#sockets" class="anchor"></a>Sockets</h2><div class="odoc-spec"><div class="spec value" id="val-accept" class="anchored"><a href="#val-accept" class="anchor"></a><code><span><span class="keyword">val</span> accept : <span>sw:<a href="../../../eio/Eio/Switch/index.html#type-t">Eio.Std.Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../FD/index.html#type-t">FD.t</a> * <span class="xref-unresolved">Unix</span>.sockaddr</span></code></div><div class="spec-doc"><p><code>accept ~sw t</code> blocks until a new connection is received on listening socket <code>t</code>.</p><p>It returns the new connection and the address of the connecting peer. The new connection has the close-on-exec flag set automatically. The new connection is attached to <code>sw</code> and will be closed when that finishes, if not already closed manually by then.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shutdown" class="anchored"><a href="#val-shutdown" class="anchor"></a><code><span><span class="keyword">val</span> shutdown : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Unix</span>.shutdown_command <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Like <code>Unix</code>.shutdown.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-send_msg" class="anchored"><a href="#val-send_msg" class="anchor"></a><code><span><span class="keyword">val</span> send_msg : 
  <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?fds:<span><a href="../FD/index.html#type-t">FD.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?dst:<span class="xref-unresolved">Unix</span>.sockaddr <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>send_msg socket bufs</code> is like <code>writev socket bufs</code>, but also allows setting the destination address (for unconnected sockets) and attaching FDs (for Unix-domain sockets).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-recv_msg" class="anchored"><a href="#val-recv_msg" class="anchor"></a><code><span><span class="keyword">val</span> recv_msg : <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Uring</span>.Sockaddr.t * int</span></code></div><div class="spec-doc"><p><code>recv_msg socket bufs</code> is like <code>readv socket bufs</code> but also returns the address of the sender.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-recv_msg_with_fds" class="anchored"><a href="#val-recv_msg_with_fds" class="anchor"></a><code><span><span class="keyword">val</span> recv_msg_with_fds : 
  <span>sw:<a href="../../../eio/Eio/Switch/index.html#type-t">Eio.Std.Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>max_fds:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../FD/index.html#type-t">FD.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Uring</span>.Sockaddr.t * int * <span><a href="../FD/index.html#type-t">FD.t</a> list</span></span></code></div><div class="spec-doc"><p><code>recv_msg_with_fds</code> is like <code>recv_msg</code> but also allows receiving up to <code>max_fds</code> file descriptors (sent using SCM_RIGHTS over a Unix domain socket).</p></div></div><h2 id="randomness"><a href="#randomness" class="anchor"></a>Randomness</h2><div class="odoc-spec"><div class="spec value" id="val-getrandom" class="anchored"><a href="#val-getrandom" class="anchor"></a><code><span><span class="keyword">val</span> getrandom : <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code> getrandom buf</code> reads some random bytes into <code>buf</code> and returns the number of bytes written.</p><p>It uses Linux's <code>getrandom</code> call, which is like reading from /dev/urandom except that it will block (the whole domain) if used at early boot when the random system hasn't been initialised yet.</p></div></div></div></body></html>